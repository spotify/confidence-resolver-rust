// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        v5.29.3
// source: confidence/flags/types/v1/target.proto

package v1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Targeting struct {
	state         protoimpl.MessageState          `protogen:"open.v1"`
	Criteria      map[string]*Targeting_Criterion `protobuf:"bytes,1,rep,name=criteria,proto3" json:"criteria,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Expression    *Expression                     `protobuf:"bytes,2,opt,name=expression,proto3" json:"expression,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Targeting) Reset() {
	*x = Targeting{}
	mi := &file_confidence_flags_types_v1_target_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Targeting) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Targeting) ProtoMessage() {}

func (x *Targeting) ProtoReflect() protoreflect.Message {
	mi := &file_confidence_flags_types_v1_target_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Targeting.ProtoReflect.Descriptor instead.
func (*Targeting) Descriptor() ([]byte, []int) {
	return file_confidence_flags_types_v1_target_proto_rawDescGZIP(), []int{0}
}

func (x *Targeting) GetCriteria() map[string]*Targeting_Criterion {
	if x != nil {
		return x.Criteria
	}
	return nil
}

func (x *Targeting) GetExpression() *Expression {
	if x != nil {
		return x.Expression
	}
	return nil
}

// A boolean expression with leaf nodes that reference criteria elements
type Expression struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Expression:
	//
	//	*Expression_Ref
	//	*Expression_Not
	//	*Expression_And
	//	*Expression_Or
	Expression    isExpression_Expression `protobuf_oneof:"expression"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Expression) Reset() {
	*x = Expression{}
	mi := &file_confidence_flags_types_v1_target_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Expression) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Expression) ProtoMessage() {}

func (x *Expression) ProtoReflect() protoreflect.Message {
	mi := &file_confidence_flags_types_v1_target_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Expression.ProtoReflect.Descriptor instead.
func (*Expression) Descriptor() ([]byte, []int) {
	return file_confidence_flags_types_v1_target_proto_rawDescGZIP(), []int{1}
}

func (x *Expression) GetExpression() isExpression_Expression {
	if x != nil {
		return x.Expression
	}
	return nil
}

func (x *Expression) GetRef() string {
	if x != nil {
		if x, ok := x.Expression.(*Expression_Ref); ok {
			return x.Ref
		}
	}
	return ""
}

func (x *Expression) GetNot() *Expression {
	if x != nil {
		if x, ok := x.Expression.(*Expression_Not); ok {
			return x.Not
		}
	}
	return nil
}

func (x *Expression) GetAnd() *Expression_Operands {
	if x != nil {
		if x, ok := x.Expression.(*Expression_And); ok {
			return x.And
		}
	}
	return nil
}

func (x *Expression) GetOr() *Expression_Operands {
	if x != nil {
		if x, ok := x.Expression.(*Expression_Or); ok {
			return x.Or
		}
	}
	return nil
}

type isExpression_Expression interface {
	isExpression_Expression()
}

type Expression_Ref struct {
	Ref string `protobuf:"bytes,1,opt,name=ref,proto3,oneof"`
}

type Expression_Not struct {
	Not *Expression `protobuf:"bytes,2,opt,name=not,proto3,oneof"`
}

type Expression_And struct {
	And *Expression_Operands `protobuf:"bytes,3,opt,name=and,proto3,oneof"`
}

type Expression_Or struct {
	Or *Expression_Operands `protobuf:"bytes,4,opt,name=or,proto3,oneof"`
}

func (*Expression_Ref) isExpression_Expression() {}

func (*Expression_Not) isExpression_Expression() {}

func (*Expression_And) isExpression_Expression() {}

func (*Expression_Or) isExpression_Expression() {}

type Targeting_Criterion struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Criterion:
	//
	//	*Targeting_Criterion_Attribute
	//	*Targeting_Criterion_Segment
	Criterion     isTargeting_Criterion_Criterion `protobuf_oneof:"criterion"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Targeting_Criterion) Reset() {
	*x = Targeting_Criterion{}
	mi := &file_confidence_flags_types_v1_target_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Targeting_Criterion) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Targeting_Criterion) ProtoMessage() {}

func (x *Targeting_Criterion) ProtoReflect() protoreflect.Message {
	mi := &file_confidence_flags_types_v1_target_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Targeting_Criterion.ProtoReflect.Descriptor instead.
func (*Targeting_Criterion) Descriptor() ([]byte, []int) {
	return file_confidence_flags_types_v1_target_proto_rawDescGZIP(), []int{0, 1}
}

func (x *Targeting_Criterion) GetCriterion() isTargeting_Criterion_Criterion {
	if x != nil {
		return x.Criterion
	}
	return nil
}

func (x *Targeting_Criterion) GetAttribute() *Targeting_Criterion_AttributeCriterion {
	if x != nil {
		if x, ok := x.Criterion.(*Targeting_Criterion_Attribute); ok {
			return x.Attribute
		}
	}
	return nil
}

func (x *Targeting_Criterion) GetSegment() *Targeting_Criterion_SegmentCriterion {
	if x != nil {
		if x, ok := x.Criterion.(*Targeting_Criterion_Segment); ok {
			return x.Segment
		}
	}
	return nil
}

type isTargeting_Criterion_Criterion interface {
	isTargeting_Criterion_Criterion()
}

type Targeting_Criterion_Attribute struct {
	Attribute *Targeting_Criterion_AttributeCriterion `protobuf:"bytes,1,opt,name=attribute,proto3,oneof"`
}

type Targeting_Criterion_Segment struct {
	Segment *Targeting_Criterion_SegmentCriterion `protobuf:"bytes,2,opt,name=segment,proto3,oneof"`
}

func (*Targeting_Criterion_Attribute) isTargeting_Criterion_Criterion() {}

func (*Targeting_Criterion_Segment) isTargeting_Criterion_Criterion() {}

// is match if at least one input item matches the inner rule
// is not match if the input list is empty/missing
type Targeting_AnyRule struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Rule          *Targeting_InnerRule   `protobuf:"bytes,1,opt,name=rule,proto3" json:"rule,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Targeting_AnyRule) Reset() {
	*x = Targeting_AnyRule{}
	mi := &file_confidence_flags_types_v1_target_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Targeting_AnyRule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Targeting_AnyRule) ProtoMessage() {}

func (x *Targeting_AnyRule) ProtoReflect() protoreflect.Message {
	mi := &file_confidence_flags_types_v1_target_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Targeting_AnyRule.ProtoReflect.Descriptor instead.
func (*Targeting_AnyRule) Descriptor() ([]byte, []int) {
	return file_confidence_flags_types_v1_target_proto_rawDescGZIP(), []int{0, 2}
}

func (x *Targeting_AnyRule) GetRule() *Targeting_InnerRule {
	if x != nil {
		return x.Rule
	}
	return nil
}

// is match if each and every input item matches the inner rule
// is also match if the input field is empty/missing
type Targeting_AllRule struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Rule          *Targeting_InnerRule   `protobuf:"bytes,1,opt,name=rule,proto3" json:"rule,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Targeting_AllRule) Reset() {
	*x = Targeting_AllRule{}
	mi := &file_confidence_flags_types_v1_target_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Targeting_AllRule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Targeting_AllRule) ProtoMessage() {}

func (x *Targeting_AllRule) ProtoReflect() protoreflect.Message {
	mi := &file_confidence_flags_types_v1_target_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Targeting_AllRule.ProtoReflect.Descriptor instead.
func (*Targeting_AllRule) Descriptor() ([]byte, []int) {
	return file_confidence_flags_types_v1_target_proto_rawDescGZIP(), []int{0, 3}
}

func (x *Targeting_AllRule) GetRule() *Targeting_InnerRule {
	if x != nil {
		return x.Rule
	}
	return nil
}

type Targeting_InnerRule struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Rule:
	//
	//	*Targeting_InnerRule_EqRule
	//	*Targeting_InnerRule_SetRule
	//	*Targeting_InnerRule_RangeRule
	Rule          isTargeting_InnerRule_Rule `protobuf_oneof:"rule"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Targeting_InnerRule) Reset() {
	*x = Targeting_InnerRule{}
	mi := &file_confidence_flags_types_v1_target_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Targeting_InnerRule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Targeting_InnerRule) ProtoMessage() {}

func (x *Targeting_InnerRule) ProtoReflect() protoreflect.Message {
	mi := &file_confidence_flags_types_v1_target_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Targeting_InnerRule.ProtoReflect.Descriptor instead.
func (*Targeting_InnerRule) Descriptor() ([]byte, []int) {
	return file_confidence_flags_types_v1_target_proto_rawDescGZIP(), []int{0, 4}
}

func (x *Targeting_InnerRule) GetRule() isTargeting_InnerRule_Rule {
	if x != nil {
		return x.Rule
	}
	return nil
}

func (x *Targeting_InnerRule) GetEqRule() *Targeting_EqRule {
	if x != nil {
		if x, ok := x.Rule.(*Targeting_InnerRule_EqRule); ok {
			return x.EqRule
		}
	}
	return nil
}

func (x *Targeting_InnerRule) GetSetRule() *Targeting_SetRule {
	if x != nil {
		if x, ok := x.Rule.(*Targeting_InnerRule_SetRule); ok {
			return x.SetRule
		}
	}
	return nil
}

func (x *Targeting_InnerRule) GetRangeRule() *Targeting_RangeRule {
	if x != nil {
		if x, ok := x.Rule.(*Targeting_InnerRule_RangeRule); ok {
			return x.RangeRule
		}
	}
	return nil
}

type isTargeting_InnerRule_Rule interface {
	isTargeting_InnerRule_Rule()
}

type Targeting_InnerRule_EqRule struct {
	EqRule *Targeting_EqRule `protobuf:"bytes,1,opt,name=eq_rule,json=eqRule,proto3,oneof"`
}

type Targeting_InnerRule_SetRule struct {
	SetRule *Targeting_SetRule `protobuf:"bytes,2,opt,name=set_rule,json=setRule,proto3,oneof"`
}

type Targeting_InnerRule_RangeRule struct {
	RangeRule *Targeting_RangeRule `protobuf:"bytes,3,opt,name=range_rule,json=rangeRule,proto3,oneof"`
}

func (*Targeting_InnerRule_EqRule) isTargeting_InnerRule_Rule() {}

func (*Targeting_InnerRule_SetRule) isTargeting_InnerRule_Rule() {}

func (*Targeting_InnerRule_RangeRule) isTargeting_InnerRule_Rule() {}

// same as SetRule with a single value
type Targeting_EqRule struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Value         *Targeting_Value       `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Targeting_EqRule) Reset() {
	*x = Targeting_EqRule{}
	mi := &file_confidence_flags_types_v1_target_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Targeting_EqRule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Targeting_EqRule) ProtoMessage() {}

func (x *Targeting_EqRule) ProtoReflect() protoreflect.Message {
	mi := &file_confidence_flags_types_v1_target_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Targeting_EqRule.ProtoReflect.Descriptor instead.
func (*Targeting_EqRule) Descriptor() ([]byte, []int) {
	return file_confidence_flags_types_v1_target_proto_rawDescGZIP(), []int{0, 5}
}

func (x *Targeting_EqRule) GetValue() *Targeting_Value {
	if x != nil {
		return x.Value
	}
	return nil
}

// represents a set of allowed values
// in {a, b, c}  -> x == a || x == b || x == c || ...
// not in {a, b} -> x != a && x != b && ...
type Targeting_SetRule struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Values        []*Targeting_Value     `protobuf:"bytes,1,rep,name=values,proto3" json:"values,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Targeting_SetRule) Reset() {
	*x = Targeting_SetRule{}
	mi := &file_confidence_flags_types_v1_target_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Targeting_SetRule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Targeting_SetRule) ProtoMessage() {}

func (x *Targeting_SetRule) ProtoReflect() protoreflect.Message {
	mi := &file_confidence_flags_types_v1_target_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Targeting_SetRule.ProtoReflect.Descriptor instead.
func (*Targeting_SetRule) Descriptor() ([]byte, []int) {
	return file_confidence_flags_types_v1_target_proto_rawDescGZIP(), []int{0, 6}
}

func (x *Targeting_SetRule) GetValues() []*Targeting_Value {
	if x != nil {
		return x.Values
	}
	return nil
}

// represents a criteria on a value using inequalities
// closed range start, end -> start <[=] x && x <[=] end
// open end start, ...     -> start <[=] x
// open start ..., end     -> x <[=] end
type Targeting_RangeRule struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Start:
	//
	//	*Targeting_RangeRule_StartInclusive
	//	*Targeting_RangeRule_StartExclusive
	Start isTargeting_RangeRule_Start `protobuf_oneof:"start"`
	// Types that are valid to be assigned to End:
	//
	//	*Targeting_RangeRule_EndInclusive
	//	*Targeting_RangeRule_EndExclusive
	End           isTargeting_RangeRule_End `protobuf_oneof:"end"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Targeting_RangeRule) Reset() {
	*x = Targeting_RangeRule{}
	mi := &file_confidence_flags_types_v1_target_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Targeting_RangeRule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Targeting_RangeRule) ProtoMessage() {}

func (x *Targeting_RangeRule) ProtoReflect() protoreflect.Message {
	mi := &file_confidence_flags_types_v1_target_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Targeting_RangeRule.ProtoReflect.Descriptor instead.
func (*Targeting_RangeRule) Descriptor() ([]byte, []int) {
	return file_confidence_flags_types_v1_target_proto_rawDescGZIP(), []int{0, 7}
}

func (x *Targeting_RangeRule) GetStart() isTargeting_RangeRule_Start {
	if x != nil {
		return x.Start
	}
	return nil
}

func (x *Targeting_RangeRule) GetStartInclusive() *Targeting_Value {
	if x != nil {
		if x, ok := x.Start.(*Targeting_RangeRule_StartInclusive); ok {
			return x.StartInclusive
		}
	}
	return nil
}

func (x *Targeting_RangeRule) GetStartExclusive() *Targeting_Value {
	if x != nil {
		if x, ok := x.Start.(*Targeting_RangeRule_StartExclusive); ok {
			return x.StartExclusive
		}
	}
	return nil
}

func (x *Targeting_RangeRule) GetEnd() isTargeting_RangeRule_End {
	if x != nil {
		return x.End
	}
	return nil
}

func (x *Targeting_RangeRule) GetEndInclusive() *Targeting_Value {
	if x != nil {
		if x, ok := x.End.(*Targeting_RangeRule_EndInclusive); ok {
			return x.EndInclusive
		}
	}
	return nil
}

func (x *Targeting_RangeRule) GetEndExclusive() *Targeting_Value {
	if x != nil {
		if x, ok := x.End.(*Targeting_RangeRule_EndExclusive); ok {
			return x.EndExclusive
		}
	}
	return nil
}

type isTargeting_RangeRule_Start interface {
	isTargeting_RangeRule_Start()
}

type Targeting_RangeRule_StartInclusive struct {
	StartInclusive *Targeting_Value `protobuf:"bytes,1,opt,name=start_inclusive,json=startInclusive,proto3,oneof"`
}

type Targeting_RangeRule_StartExclusive struct {
	StartExclusive *Targeting_Value `protobuf:"bytes,2,opt,name=start_exclusive,json=startExclusive,proto3,oneof"`
}

func (*Targeting_RangeRule_StartInclusive) isTargeting_RangeRule_Start() {}

func (*Targeting_RangeRule_StartExclusive) isTargeting_RangeRule_Start() {}

type isTargeting_RangeRule_End interface {
	isTargeting_RangeRule_End()
}

type Targeting_RangeRule_EndInclusive struct {
	EndInclusive *Targeting_Value `protobuf:"bytes,3,opt,name=end_inclusive,json=endInclusive,proto3,oneof"`
}

type Targeting_RangeRule_EndExclusive struct {
	EndExclusive *Targeting_Value `protobuf:"bytes,4,opt,name=end_exclusive,json=endExclusive,proto3,oneof"`
}

func (*Targeting_RangeRule_EndInclusive) isTargeting_RangeRule_End() {}

func (*Targeting_RangeRule_EndExclusive) isTargeting_RangeRule_End() {}

// equality (==, !=, ∈) defined for all types
// comparison (<, <=, >, >=) defined for number, timestamp, version
type Targeting_Value struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Value:
	//
	//	*Targeting_Value_BoolValue
	//	*Targeting_Value_NumberValue
	//	*Targeting_Value_StringValue
	//	*Targeting_Value_TimestampValue
	//	*Targeting_Value_VersionValue
	//	*Targeting_Value_ListValue
	Value         isTargeting_Value_Value `protobuf_oneof:"value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Targeting_Value) Reset() {
	*x = Targeting_Value{}
	mi := &file_confidence_flags_types_v1_target_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Targeting_Value) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Targeting_Value) ProtoMessage() {}

func (x *Targeting_Value) ProtoReflect() protoreflect.Message {
	mi := &file_confidence_flags_types_v1_target_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Targeting_Value.ProtoReflect.Descriptor instead.
func (*Targeting_Value) Descriptor() ([]byte, []int) {
	return file_confidence_flags_types_v1_target_proto_rawDescGZIP(), []int{0, 8}
}

func (x *Targeting_Value) GetValue() isTargeting_Value_Value {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *Targeting_Value) GetBoolValue() bool {
	if x != nil {
		if x, ok := x.Value.(*Targeting_Value_BoolValue); ok {
			return x.BoolValue
		}
	}
	return false
}

func (x *Targeting_Value) GetNumberValue() float64 {
	if x != nil {
		if x, ok := x.Value.(*Targeting_Value_NumberValue); ok {
			return x.NumberValue
		}
	}
	return 0
}

func (x *Targeting_Value) GetStringValue() string {
	if x != nil {
		if x, ok := x.Value.(*Targeting_Value_StringValue); ok {
			return x.StringValue
		}
	}
	return ""
}

func (x *Targeting_Value) GetTimestampValue() *timestamppb.Timestamp {
	if x != nil {
		if x, ok := x.Value.(*Targeting_Value_TimestampValue); ok {
			return x.TimestampValue
		}
	}
	return nil
}

func (x *Targeting_Value) GetVersionValue() *Targeting_SemanticVersion {
	if x != nil {
		if x, ok := x.Value.(*Targeting_Value_VersionValue); ok {
			return x.VersionValue
		}
	}
	return nil
}

func (x *Targeting_Value) GetListValue() *Targeting_ListValue {
	if x != nil {
		if x, ok := x.Value.(*Targeting_Value_ListValue); ok {
			return x.ListValue
		}
	}
	return nil
}

type isTargeting_Value_Value interface {
	isTargeting_Value_Value()
}

type Targeting_Value_BoolValue struct {
	BoolValue bool `protobuf:"varint,1,opt,name=bool_value,json=boolValue,proto3,oneof"`
}

type Targeting_Value_NumberValue struct {
	NumberValue float64 `protobuf:"fixed64,7,opt,name=number_value,json=numberValue,proto3,oneof"`
}

type Targeting_Value_StringValue struct {
	StringValue string `protobuf:"bytes,4,opt,name=string_value,json=stringValue,proto3,oneof"`
}

type Targeting_Value_TimestampValue struct {
	TimestampValue *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=timestamp_value,json=timestampValue,proto3,oneof"`
}

type Targeting_Value_VersionValue struct {
	VersionValue *Targeting_SemanticVersion `protobuf:"bytes,6,opt,name=version_value,json=versionValue,proto3,oneof"`
}

type Targeting_Value_ListValue struct {
	ListValue *Targeting_ListValue `protobuf:"bytes,8,opt,name=list_value,json=listValue,proto3,oneof"`
}

func (*Targeting_Value_BoolValue) isTargeting_Value_Value() {}

func (*Targeting_Value_NumberValue) isTargeting_Value_Value() {}

func (*Targeting_Value_StringValue) isTargeting_Value_Value() {}

func (*Targeting_Value_TimestampValue) isTargeting_Value_Value() {}

func (*Targeting_Value_VersionValue) isTargeting_Value_Value() {}

func (*Targeting_Value_ListValue) isTargeting_Value_Value() {}

type Targeting_ListValue struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Values        []*Targeting_Value     `protobuf:"bytes,1,rep,name=values,proto3" json:"values,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Targeting_ListValue) Reset() {
	*x = Targeting_ListValue{}
	mi := &file_confidence_flags_types_v1_target_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Targeting_ListValue) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Targeting_ListValue) ProtoMessage() {}

func (x *Targeting_ListValue) ProtoReflect() protoreflect.Message {
	mi := &file_confidence_flags_types_v1_target_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Targeting_ListValue.ProtoReflect.Descriptor instead.
func (*Targeting_ListValue) Descriptor() ([]byte, []int) {
	return file_confidence_flags_types_v1_target_proto_rawDescGZIP(), []int{0, 9}
}

func (x *Targeting_ListValue) GetValues() []*Targeting_Value {
	if x != nil {
		return x.Values
	}
	return nil
}

type Targeting_SemanticVersion struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Version       string                 `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Targeting_SemanticVersion) Reset() {
	*x = Targeting_SemanticVersion{}
	mi := &file_confidence_flags_types_v1_target_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Targeting_SemanticVersion) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Targeting_SemanticVersion) ProtoMessage() {}

func (x *Targeting_SemanticVersion) ProtoReflect() protoreflect.Message {
	mi := &file_confidence_flags_types_v1_target_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Targeting_SemanticVersion.ProtoReflect.Descriptor instead.
func (*Targeting_SemanticVersion) Descriptor() ([]byte, []int) {
	return file_confidence_flags_types_v1_target_proto_rawDescGZIP(), []int{0, 10}
}

func (x *Targeting_SemanticVersion) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

type Targeting_Criterion_AttributeCriterion struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	AttributeName string                 `protobuf:"bytes,1,opt,name=attribute_name,json=attributeName,proto3" json:"attribute_name,omitempty"`
	// Types that are valid to be assigned to Rule:
	//
	//	*Targeting_Criterion_AttributeCriterion_EqRule
	//	*Targeting_Criterion_AttributeCriterion_SetRule
	//	*Targeting_Criterion_AttributeCriterion_RangeRule
	//	*Targeting_Criterion_AttributeCriterion_AnyRule
	//	*Targeting_Criterion_AttributeCriterion_AllRule
	Rule          isTargeting_Criterion_AttributeCriterion_Rule `protobuf_oneof:"rule"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Targeting_Criterion_AttributeCriterion) Reset() {
	*x = Targeting_Criterion_AttributeCriterion{}
	mi := &file_confidence_flags_types_v1_target_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Targeting_Criterion_AttributeCriterion) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Targeting_Criterion_AttributeCriterion) ProtoMessage() {}

func (x *Targeting_Criterion_AttributeCriterion) ProtoReflect() protoreflect.Message {
	mi := &file_confidence_flags_types_v1_target_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Targeting_Criterion_AttributeCriterion.ProtoReflect.Descriptor instead.
func (*Targeting_Criterion_AttributeCriterion) Descriptor() ([]byte, []int) {
	return file_confidence_flags_types_v1_target_proto_rawDescGZIP(), []int{0, 1, 0}
}

func (x *Targeting_Criterion_AttributeCriterion) GetAttributeName() string {
	if x != nil {
		return x.AttributeName
	}
	return ""
}

func (x *Targeting_Criterion_AttributeCriterion) GetRule() isTargeting_Criterion_AttributeCriterion_Rule {
	if x != nil {
		return x.Rule
	}
	return nil
}

func (x *Targeting_Criterion_AttributeCriterion) GetEqRule() *Targeting_EqRule {
	if x != nil {
		if x, ok := x.Rule.(*Targeting_Criterion_AttributeCriterion_EqRule); ok {
			return x.EqRule
		}
	}
	return nil
}

func (x *Targeting_Criterion_AttributeCriterion) GetSetRule() *Targeting_SetRule {
	if x != nil {
		if x, ok := x.Rule.(*Targeting_Criterion_AttributeCriterion_SetRule); ok {
			return x.SetRule
		}
	}
	return nil
}

func (x *Targeting_Criterion_AttributeCriterion) GetRangeRule() *Targeting_RangeRule {
	if x != nil {
		if x, ok := x.Rule.(*Targeting_Criterion_AttributeCriterion_RangeRule); ok {
			return x.RangeRule
		}
	}
	return nil
}

func (x *Targeting_Criterion_AttributeCriterion) GetAnyRule() *Targeting_AnyRule {
	if x != nil {
		if x, ok := x.Rule.(*Targeting_Criterion_AttributeCriterion_AnyRule); ok {
			return x.AnyRule
		}
	}
	return nil
}

func (x *Targeting_Criterion_AttributeCriterion) GetAllRule() *Targeting_AllRule {
	if x != nil {
		if x, ok := x.Rule.(*Targeting_Criterion_AttributeCriterion_AllRule); ok {
			return x.AllRule
		}
	}
	return nil
}

type isTargeting_Criterion_AttributeCriterion_Rule interface {
	isTargeting_Criterion_AttributeCriterion_Rule()
}

type Targeting_Criterion_AttributeCriterion_EqRule struct {
	EqRule *Targeting_EqRule `protobuf:"bytes,2,opt,name=eq_rule,json=eqRule,proto3,oneof"`
}

type Targeting_Criterion_AttributeCriterion_SetRule struct {
	SetRule *Targeting_SetRule `protobuf:"bytes,3,opt,name=set_rule,json=setRule,proto3,oneof"`
}

type Targeting_Criterion_AttributeCriterion_RangeRule struct {
	RangeRule *Targeting_RangeRule `protobuf:"bytes,4,opt,name=range_rule,json=rangeRule,proto3,oneof"`
}

type Targeting_Criterion_AttributeCriterion_AnyRule struct {
	AnyRule *Targeting_AnyRule `protobuf:"bytes,5,opt,name=any_rule,json=anyRule,proto3,oneof"`
}

type Targeting_Criterion_AttributeCriterion_AllRule struct {
	AllRule *Targeting_AllRule `protobuf:"bytes,6,opt,name=all_rule,json=allRule,proto3,oneof"`
}

func (*Targeting_Criterion_AttributeCriterion_EqRule) isTargeting_Criterion_AttributeCriterion_Rule() {
}

func (*Targeting_Criterion_AttributeCriterion_SetRule) isTargeting_Criterion_AttributeCriterion_Rule() {
}

func (*Targeting_Criterion_AttributeCriterion_RangeRule) isTargeting_Criterion_AttributeCriterion_Rule() {
}

func (*Targeting_Criterion_AttributeCriterion_AnyRule) isTargeting_Criterion_AttributeCriterion_Rule() {
}

func (*Targeting_Criterion_AttributeCriterion_AllRule) isTargeting_Criterion_AttributeCriterion_Rule() {
}

type Targeting_Criterion_SegmentCriterion struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Segment       string                 `protobuf:"bytes,1,opt,name=segment,proto3" json:"segment,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Targeting_Criterion_SegmentCriterion) Reset() {
	*x = Targeting_Criterion_SegmentCriterion{}
	mi := &file_confidence_flags_types_v1_target_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Targeting_Criterion_SegmentCriterion) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Targeting_Criterion_SegmentCriterion) ProtoMessage() {}

func (x *Targeting_Criterion_SegmentCriterion) ProtoReflect() protoreflect.Message {
	mi := &file_confidence_flags_types_v1_target_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Targeting_Criterion_SegmentCriterion.ProtoReflect.Descriptor instead.
func (*Targeting_Criterion_SegmentCriterion) Descriptor() ([]byte, []int) {
	return file_confidence_flags_types_v1_target_proto_rawDescGZIP(), []int{0, 1, 1}
}

func (x *Targeting_Criterion_SegmentCriterion) GetSegment() string {
	if x != nil {
		return x.Segment
	}
	return ""
}

type Expression_Operands struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Operands      []*Expression          `protobuf:"bytes,1,rep,name=operands,proto3" json:"operands,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Expression_Operands) Reset() {
	*x = Expression_Operands{}
	mi := &file_confidence_flags_types_v1_target_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Expression_Operands) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Expression_Operands) ProtoMessage() {}

func (x *Expression_Operands) ProtoReflect() protoreflect.Message {
	mi := &file_confidence_flags_types_v1_target_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Expression_Operands.ProtoReflect.Descriptor instead.
func (*Expression_Operands) Descriptor() ([]byte, []int) {
	return file_confidence_flags_types_v1_target_proto_rawDescGZIP(), []int{1, 0}
}

func (x *Expression_Operands) GetOperands() []*Expression {
	if x != nil {
		return x.Operands
	}
	return nil
}

var File_confidence_flags_types_v1_target_proto protoreflect.FileDescriptor

const file_confidence_flags_types_v1_target_proto_rawDesc = "" +
	"\n" +
	"&confidence/flags/types/v1/target.proto\x12\x19confidence.flags.types.v1\x1a\x1fgoogle/protobuf/timestamp.proto\"\xee\x12\n" +
	"\tTargeting\x12N\n" +
	"\bcriteria\x18\x01 \x03(\v22.confidence.flags.types.v1.Targeting.CriteriaEntryR\bcriteria\x12E\n" +
	"\n" +
	"expression\x18\x02 \x01(\v2%.confidence.flags.types.v1.ExpressionR\n" +
	"expression\x1ak\n" +
	"\rCriteriaEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12D\n" +
	"\x05value\x18\x02 \x01(\v2..confidence.flags.types.v1.Targeting.CriterionR\x05value:\x028\x01\x1a\xc6\x05\n" +
	"\tCriterion\x12a\n" +
	"\tattribute\x18\x01 \x01(\v2A.confidence.flags.types.v1.Targeting.Criterion.AttributeCriterionH\x00R\tattribute\x12[\n" +
	"\asegment\x18\x02 \x01(\v2?.confidence.flags.types.v1.Targeting.Criterion.SegmentCriterionH\x00R\asegment\x1a\xbd\x03\n" +
	"\x12AttributeCriterion\x12%\n" +
	"\x0eattribute_name\x18\x01 \x01(\tR\rattributeName\x12F\n" +
	"\aeq_rule\x18\x02 \x01(\v2+.confidence.flags.types.v1.Targeting.EqRuleH\x00R\x06eqRule\x12I\n" +
	"\bset_rule\x18\x03 \x01(\v2,.confidence.flags.types.v1.Targeting.SetRuleH\x00R\asetRule\x12O\n" +
	"\n" +
	"range_rule\x18\x04 \x01(\v2..confidence.flags.types.v1.Targeting.RangeRuleH\x00R\trangeRule\x12I\n" +
	"\bany_rule\x18\x05 \x01(\v2,.confidence.flags.types.v1.Targeting.AnyRuleH\x00R\aanyRule\x12I\n" +
	"\ball_rule\x18\x06 \x01(\v2,.confidence.flags.types.v1.Targeting.AllRuleH\x00R\aallRuleB\x06\n" +
	"\x04rule\x1a,\n" +
	"\x10SegmentCriterion\x12\x18\n" +
	"\asegment\x18\x01 \x01(\tR\asegmentB\v\n" +
	"\tcriterion\x1aM\n" +
	"\aAnyRule\x12B\n" +
	"\x04rule\x18\x01 \x01(\v2..confidence.flags.types.v1.Targeting.InnerRuleR\x04rule\x1aM\n" +
	"\aAllRule\x12B\n" +
	"\x04rule\x18\x01 \x01(\v2..confidence.flags.types.v1.Targeting.InnerRuleR\x04rule\x1a\xf7\x01\n" +
	"\tInnerRule\x12F\n" +
	"\aeq_rule\x18\x01 \x01(\v2+.confidence.flags.types.v1.Targeting.EqRuleH\x00R\x06eqRule\x12I\n" +
	"\bset_rule\x18\x02 \x01(\v2,.confidence.flags.types.v1.Targeting.SetRuleH\x00R\asetRule\x12O\n" +
	"\n" +
	"range_rule\x18\x03 \x01(\v2..confidence.flags.types.v1.Targeting.RangeRuleH\x00R\trangeRuleB\x06\n" +
	"\x04rule\x1aJ\n" +
	"\x06EqRule\x12@\n" +
	"\x05value\x18\x01 \x01(\v2*.confidence.flags.types.v1.Targeting.ValueR\x05value\x1aM\n" +
	"\aSetRule\x12B\n" +
	"\x06values\x18\x01 \x03(\v2*.confidence.flags.types.v1.Targeting.ValueR\x06values\x1a\xef\x02\n" +
	"\tRangeRule\x12U\n" +
	"\x0fstart_inclusive\x18\x01 \x01(\v2*.confidence.flags.types.v1.Targeting.ValueH\x00R\x0estartInclusive\x12U\n" +
	"\x0fstart_exclusive\x18\x02 \x01(\v2*.confidence.flags.types.v1.Targeting.ValueH\x00R\x0estartExclusive\x12Q\n" +
	"\rend_inclusive\x18\x03 \x01(\v2*.confidence.flags.types.v1.Targeting.ValueH\x01R\fendInclusive\x12Q\n" +
	"\rend_exclusive\x18\x04 \x01(\v2*.confidence.flags.types.v1.Targeting.ValueH\x01R\fendExclusiveB\a\n" +
	"\x05startB\x05\n" +
	"\x03end\x1a\xf0\x02\n" +
	"\x05Value\x12\x1f\n" +
	"\n" +
	"bool_value\x18\x01 \x01(\bH\x00R\tboolValue\x12#\n" +
	"\fnumber_value\x18\a \x01(\x01H\x00R\vnumberValue\x12#\n" +
	"\fstring_value\x18\x04 \x01(\tH\x00R\vstringValue\x12E\n" +
	"\x0ftimestamp_value\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampH\x00R\x0etimestampValue\x12[\n" +
	"\rversion_value\x18\x06 \x01(\v24.confidence.flags.types.v1.Targeting.SemanticVersionH\x00R\fversionValue\x12O\n" +
	"\n" +
	"list_value\x18\b \x01(\v2..confidence.flags.types.v1.Targeting.ListValueH\x00R\tlistValueB\a\n" +
	"\x05value\x1aO\n" +
	"\tListValue\x12B\n" +
	"\x06values\x18\x01 \x03(\v2*.confidence.flags.types.v1.Targeting.ValueR\x06values\x1a+\n" +
	"\x0fSemanticVersion\x12\x18\n" +
	"\aversion\x18\x01 \x01(\tR\aversion\"\xbe\x02\n" +
	"\n" +
	"Expression\x12\x12\n" +
	"\x03ref\x18\x01 \x01(\tH\x00R\x03ref\x129\n" +
	"\x03not\x18\x02 \x01(\v2%.confidence.flags.types.v1.ExpressionH\x00R\x03not\x12B\n" +
	"\x03and\x18\x03 \x01(\v2..confidence.flags.types.v1.Expression.OperandsH\x00R\x03and\x12@\n" +
	"\x02or\x18\x04 \x01(\v2..confidence.flags.types.v1.Expression.OperandsH\x00R\x02or\x1aM\n" +
	"\bOperands\x12A\n" +
	"\boperands\x18\x01 \x03(\v2%.confidence.flags.types.v1.ExpressionR\boperandsB\f\n" +
	"\n" +
	"expressionB9\n" +
	"%com.spotify.confidence.flags.types.v1B\x0eTargetingProtoP\x01b\x06proto3"

var (
	file_confidence_flags_types_v1_target_proto_rawDescOnce sync.Once
	file_confidence_flags_types_v1_target_proto_rawDescData []byte
)

func file_confidence_flags_types_v1_target_proto_rawDescGZIP() []byte {
	file_confidence_flags_types_v1_target_proto_rawDescOnce.Do(func() {
		file_confidence_flags_types_v1_target_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_confidence_flags_types_v1_target_proto_rawDesc), len(file_confidence_flags_types_v1_target_proto_rawDesc)))
	})
	return file_confidence_flags_types_v1_target_proto_rawDescData
}

var file_confidence_flags_types_v1_target_proto_msgTypes = make([]protoimpl.MessageInfo, 16)
var file_confidence_flags_types_v1_target_proto_goTypes = []any{
	(*Targeting)(nil),                              // 0: confidence.flags.types.v1.Targeting
	(*Expression)(nil),                             // 1: confidence.flags.types.v1.Expression
	nil,                                            // 2: confidence.flags.types.v1.Targeting.CriteriaEntry
	(*Targeting_Criterion)(nil),                    // 3: confidence.flags.types.v1.Targeting.Criterion
	(*Targeting_AnyRule)(nil),                      // 4: confidence.flags.types.v1.Targeting.AnyRule
	(*Targeting_AllRule)(nil),                      // 5: confidence.flags.types.v1.Targeting.AllRule
	(*Targeting_InnerRule)(nil),                    // 6: confidence.flags.types.v1.Targeting.InnerRule
	(*Targeting_EqRule)(nil),                       // 7: confidence.flags.types.v1.Targeting.EqRule
	(*Targeting_SetRule)(nil),                      // 8: confidence.flags.types.v1.Targeting.SetRule
	(*Targeting_RangeRule)(nil),                    // 9: confidence.flags.types.v1.Targeting.RangeRule
	(*Targeting_Value)(nil),                        // 10: confidence.flags.types.v1.Targeting.Value
	(*Targeting_ListValue)(nil),                    // 11: confidence.flags.types.v1.Targeting.ListValue
	(*Targeting_SemanticVersion)(nil),              // 12: confidence.flags.types.v1.Targeting.SemanticVersion
	(*Targeting_Criterion_AttributeCriterion)(nil), // 13: confidence.flags.types.v1.Targeting.Criterion.AttributeCriterion
	(*Targeting_Criterion_SegmentCriterion)(nil),   // 14: confidence.flags.types.v1.Targeting.Criterion.SegmentCriterion
	(*Expression_Operands)(nil),                    // 15: confidence.flags.types.v1.Expression.Operands
	(*timestamppb.Timestamp)(nil),                  // 16: google.protobuf.Timestamp
}
var file_confidence_flags_types_v1_target_proto_depIdxs = []int32{
	2,  // 0: confidence.flags.types.v1.Targeting.criteria:type_name -> confidence.flags.types.v1.Targeting.CriteriaEntry
	1,  // 1: confidence.flags.types.v1.Targeting.expression:type_name -> confidence.flags.types.v1.Expression
	1,  // 2: confidence.flags.types.v1.Expression.not:type_name -> confidence.flags.types.v1.Expression
	15, // 3: confidence.flags.types.v1.Expression.and:type_name -> confidence.flags.types.v1.Expression.Operands
	15, // 4: confidence.flags.types.v1.Expression.or:type_name -> confidence.flags.types.v1.Expression.Operands
	3,  // 5: confidence.flags.types.v1.Targeting.CriteriaEntry.value:type_name -> confidence.flags.types.v1.Targeting.Criterion
	13, // 6: confidence.flags.types.v1.Targeting.Criterion.attribute:type_name -> confidence.flags.types.v1.Targeting.Criterion.AttributeCriterion
	14, // 7: confidence.flags.types.v1.Targeting.Criterion.segment:type_name -> confidence.flags.types.v1.Targeting.Criterion.SegmentCriterion
	6,  // 8: confidence.flags.types.v1.Targeting.AnyRule.rule:type_name -> confidence.flags.types.v1.Targeting.InnerRule
	6,  // 9: confidence.flags.types.v1.Targeting.AllRule.rule:type_name -> confidence.flags.types.v1.Targeting.InnerRule
	7,  // 10: confidence.flags.types.v1.Targeting.InnerRule.eq_rule:type_name -> confidence.flags.types.v1.Targeting.EqRule
	8,  // 11: confidence.flags.types.v1.Targeting.InnerRule.set_rule:type_name -> confidence.flags.types.v1.Targeting.SetRule
	9,  // 12: confidence.flags.types.v1.Targeting.InnerRule.range_rule:type_name -> confidence.flags.types.v1.Targeting.RangeRule
	10, // 13: confidence.flags.types.v1.Targeting.EqRule.value:type_name -> confidence.flags.types.v1.Targeting.Value
	10, // 14: confidence.flags.types.v1.Targeting.SetRule.values:type_name -> confidence.flags.types.v1.Targeting.Value
	10, // 15: confidence.flags.types.v1.Targeting.RangeRule.start_inclusive:type_name -> confidence.flags.types.v1.Targeting.Value
	10, // 16: confidence.flags.types.v1.Targeting.RangeRule.start_exclusive:type_name -> confidence.flags.types.v1.Targeting.Value
	10, // 17: confidence.flags.types.v1.Targeting.RangeRule.end_inclusive:type_name -> confidence.flags.types.v1.Targeting.Value
	10, // 18: confidence.flags.types.v1.Targeting.RangeRule.end_exclusive:type_name -> confidence.flags.types.v1.Targeting.Value
	16, // 19: confidence.flags.types.v1.Targeting.Value.timestamp_value:type_name -> google.protobuf.Timestamp
	12, // 20: confidence.flags.types.v1.Targeting.Value.version_value:type_name -> confidence.flags.types.v1.Targeting.SemanticVersion
	11, // 21: confidence.flags.types.v1.Targeting.Value.list_value:type_name -> confidence.flags.types.v1.Targeting.ListValue
	10, // 22: confidence.flags.types.v1.Targeting.ListValue.values:type_name -> confidence.flags.types.v1.Targeting.Value
	7,  // 23: confidence.flags.types.v1.Targeting.Criterion.AttributeCriterion.eq_rule:type_name -> confidence.flags.types.v1.Targeting.EqRule
	8,  // 24: confidence.flags.types.v1.Targeting.Criterion.AttributeCriterion.set_rule:type_name -> confidence.flags.types.v1.Targeting.SetRule
	9,  // 25: confidence.flags.types.v1.Targeting.Criterion.AttributeCriterion.range_rule:type_name -> confidence.flags.types.v1.Targeting.RangeRule
	4,  // 26: confidence.flags.types.v1.Targeting.Criterion.AttributeCriterion.any_rule:type_name -> confidence.flags.types.v1.Targeting.AnyRule
	5,  // 27: confidence.flags.types.v1.Targeting.Criterion.AttributeCriterion.all_rule:type_name -> confidence.flags.types.v1.Targeting.AllRule
	1,  // 28: confidence.flags.types.v1.Expression.Operands.operands:type_name -> confidence.flags.types.v1.Expression
	29, // [29:29] is the sub-list for method output_type
	29, // [29:29] is the sub-list for method input_type
	29, // [29:29] is the sub-list for extension type_name
	29, // [29:29] is the sub-list for extension extendee
	0,  // [0:29] is the sub-list for field type_name
}

func init() { file_confidence_flags_types_v1_target_proto_init() }
func file_confidence_flags_types_v1_target_proto_init() {
	if File_confidence_flags_types_v1_target_proto != nil {
		return
	}
	file_confidence_flags_types_v1_target_proto_msgTypes[1].OneofWrappers = []any{
		(*Expression_Ref)(nil),
		(*Expression_Not)(nil),
		(*Expression_And)(nil),
		(*Expression_Or)(nil),
	}
	file_confidence_flags_types_v1_target_proto_msgTypes[3].OneofWrappers = []any{
		(*Targeting_Criterion_Attribute)(nil),
		(*Targeting_Criterion_Segment)(nil),
	}
	file_confidence_flags_types_v1_target_proto_msgTypes[6].OneofWrappers = []any{
		(*Targeting_InnerRule_EqRule)(nil),
		(*Targeting_InnerRule_SetRule)(nil),
		(*Targeting_InnerRule_RangeRule)(nil),
	}
	file_confidence_flags_types_v1_target_proto_msgTypes[9].OneofWrappers = []any{
		(*Targeting_RangeRule_StartInclusive)(nil),
		(*Targeting_RangeRule_StartExclusive)(nil),
		(*Targeting_RangeRule_EndInclusive)(nil),
		(*Targeting_RangeRule_EndExclusive)(nil),
	}
	file_confidence_flags_types_v1_target_proto_msgTypes[10].OneofWrappers = []any{
		(*Targeting_Value_BoolValue)(nil),
		(*Targeting_Value_NumberValue)(nil),
		(*Targeting_Value_StringValue)(nil),
		(*Targeting_Value_TimestampValue)(nil),
		(*Targeting_Value_VersionValue)(nil),
		(*Targeting_Value_ListValue)(nil),
	}
	file_confidence_flags_types_v1_target_proto_msgTypes[13].OneofWrappers = []any{
		(*Targeting_Criterion_AttributeCriterion_EqRule)(nil),
		(*Targeting_Criterion_AttributeCriterion_SetRule)(nil),
		(*Targeting_Criterion_AttributeCriterion_RangeRule)(nil),
		(*Targeting_Criterion_AttributeCriterion_AnyRule)(nil),
		(*Targeting_Criterion_AttributeCriterion_AllRule)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_confidence_flags_types_v1_target_proto_rawDesc), len(file_confidence_flags_types_v1_target_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   16,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_confidence_flags_types_v1_target_proto_goTypes,
		DependencyIndexes: file_confidence_flags_types_v1_target_proto_depIdxs,
		MessageInfos:      file_confidence_flags_types_v1_target_proto_msgTypes,
	}.Build()
	File_confidence_flags_types_v1_target_proto = out.File
	file_confidence_flags_types_v1_target_proto_goTypes = nil
	file_confidence_flags_types_v1_target_proto_depIdxs = nil
}
